<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>linux一些基本的进程管理命令</title>
      <link href="/2018/09/27/linux/"/>
      <url>/2018/09/27/linux/</url>
      <content type="html"><![CDATA[<p><em>进程相关操作，很好的提高效率哦</em></p><hr><p>进程： 执行中的程序<br>当程序以可执行文件存放在存储中，并且运行的时候，每个进程都会被动态的分配</p><ol><li>系统资源</li><li>内存</li><li>安全属性</li><li>与之相关的状态<a id="more"></a>多个进程可以关联到同一个程序，并同时执行不会互相干扰。操作系统会有效的管理和追踪所有运行着的进程</li></ol><p>为了管理这些进程，用户应该能够：</p><ol><li>查看所有运行中的进程</li><li>查看进程消耗的资源</li><li>定位个别进程并且对其执行制定操作</li><li>改变进程的优先级</li><li>杀死指定进程</li><li>限制进程可用的系统资源等</li></ol><p>Linux提供了许多命令来让用户高效掌控上述的操作</p><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>linux中最基础的浏览系统中的进程的命令。能列出系统中运行的进程，包括进程号、命令、CPU使用量、内存使用量等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -a   #列出所有运行中/激活进程</span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2018/09/27/5bac2987663ca.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2987663ca.png" alt="162704rlcdzcpj7jdvooq4.png"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef  | grep    -列出需要的进程</span><br><span class="line">ps -aux   -显示进程信息，包括无终端的(x)和针对用户（u）的进程：如USER, PID, %CPU, %MEM等</span><br></pre></td></tr></table></figure><h1 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h1><p>linux中每一个进程都是由其父进程创建的。此命令以可视化方式显示进程，通过显示进程的树状图来展示进程间的关系。如果指定pid, 那么树的根就是该pid, 不然将会是init(pid:1)</p><p><a href="https://i.loli.net/2018/09/27/5bac29c852582.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac29c852582.png" alt="162705dddkpqkzk1svlvsk.png"></a></p><h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>监视系统中不同的进程所使用的资源，提供实时系统状态信息。显示进程的数据包括PID,进程属主、优先级、%CPU、%memory等。可以使用这些显示指示出资源使用量。</p><p><a href="https://i.loli.net/2018/09/27/5bac29f80032b.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac29f80032b.png" alt="162705cvzpfd13kugv9321.png"></a></p><h1 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h1><p>交互式的文本模式的进程查看器。通过文字图形化的显示每一个进程的CPU和内存使用量、swap使用量。使用上下光标键选择进程，F7和F8改变优先级，F9杀死进程。htop不是系统默认安装的，所以需要额外安装。</p><p><a href="https://i.loli.net/2018/09/27/5bac2a1e5a9c7.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2a1e5a9c7.png" alt="162706whldzplwhdhjzogd.png"></a></p><h1 id="nice"><a href="#nice" class="headerlink" title="nice"></a>nice</h1><p>设置和改变进程的优先级。提高一个进程的优先级，内核会分配更多CPU时间片给这个进程。默认情况：进程以0的优先级启动。进程优先级可以通过top命令显示的NI（nice value）列查看。<br>进程优先级值得范围（-20-19）。值越低，优先级越高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nice&lt;优先值&gt;&lt;进程名&gt;  -通过给定的优先值启动一个程序</span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2018/09/27/5bac2a69aec31.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2a69aec31.png" alt="162706e37l4xnnqcebwt7o.png"></a></p><p><a href="https://i.loli.net/2018/09/27/5bac2a78d5121.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2a78d5121.png" alt="162707o1aunhs47whehs1s.png"></a></p><h1 id="renice"><a href="#renice" class="headerlink" title="renice"></a>renice</h1><p>改变正在运行的进程的优先值, 注意，只能改变属于他们自己的进程的优先值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice -n -p - 改变指定进程的优先值</span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2018/09/27/5bac2a9f2b421.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2a9f2b421.png" alt="162708qwie1sateaiw8pae.png"></a></p><p>初始值为0的3805号进程的优先值变成了4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice -u -g - 通过指定用户和组来改变进程优先值</span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2018/09/27/5bac2ac4045c9.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2ac4045c9.png" alt="162708bvw9hvh6o8vookv4.png"></a><br>用户为”mint”的所有进程优先值变为-3</p><h1 id="Kill"><a href="#Kill" class="headerlink" title="Kill"></a>Kill</h1><p>发送信号来结束进程。如果一个进程没有响应杀死命令，着也许就需要强制杀死，使用-9参数来执行。注意，强制杀死的时候一定要小心，因为进程没有时机清理现场，也许写入文件没有完成。如果不知道进程PID或者打算用名字杀死进程的时候，killall就能派上用场。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill &lt;pid&gt;</span><br><span class="line">kill -9 &lt;pid&gt;</span><br><span class="line">killall -9 - 杀死所有拥有同样名字的进程</span><br></pre></td></tr></table></figure><p>如果使用kill,你需要知道进程ID号，pkill是类似的命令，但使用模式匹配，如进程名，进程拥有者等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill &lt;进程名&gt;</span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2018/09/27/5bac2b171348d.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2b171348d.png" alt="162709nitkiffzqimm1zpp.png"></a></p><p><a href="https://i.loli.net/2018/09/27/5bac2b1725c22.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2b1725c22.png" alt="162709g253s5teo3335jze.png"></a></p><h1 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h1><p>控制系统资源在shell和进程上的分配量。对于系统管理员是最有用的，可以管理重度使用和存在性能问题的系统。限制资源大小可以确保重要进程持续运行，其他进程不会占用过多资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a - 显示当前用户关联的资源限制</span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2018/09/27/5bac2b44a954e.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2b44a954e.png" alt="162709oj6fxr1l9fg1h6qe.png"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-f - 最大文件尺寸大小</span><br><span class="line">-v - 最大虚拟内存大小（KB）</span><br><span class="line">-n - 增加最大文件描述符数量</span><br><span class="line">-H : 改变和报告硬限制</span><br><span class="line">-S : 改变和报告软限制</span><br></pre></td></tr></table></figure><h1 id="w"><a href="#w" class="headerlink" title="w"></a>w</h1><p>提供当前登录的用户及其正在执行的进程的信息。显示信息头包含信息，如当前的时间、系统运行时长、登录用户总数、过去的1/5/15分钟内的负载均衡数。<br>基于这些用户信息，用户在终止不属于他们的进程时要小心。</p><p><a href="https://i.loli.net/2018/09/27/5bac2b7feabc2.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2b7feabc2.png" alt="162710eccrsjsqhft1j6cq.png"></a><br>who 时类似命令，提供当前登录用户列表、系统启动时间、运行级别。</p><p><a href="https://i.loli.net/2018/09/27/5bac2b800a616.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2b800a616.png" alt="162711bmn4zyomhl5zma5a.png"></a><br>whoami命令输出当前用户ID</p><p><a href="https://i.loli.net/2018/09/27/5bac2b800bed2.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2b800bed2.png" alt="162710gagjy3crv66svba3.png"></a></p><h1 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h1><p>进程号全局正则匹配输出。扫描当前运行进程，然后按照命令匹配条件列出匹配结果到标准输出。对于通过名字检索进程号时很有用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep -u mint sh</span><br></pre></td></tr></table></figure><p>这个命令会显示用户为“mint”和进程名为”sh”的进程ID</p><p><a href="https://i.loli.net/2018/09/27/5bac2bb4393da.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac2bb4393da.png" alt="162711azncon8i4ijrqc8n.png"></a></p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中的error和exception基础</title>
      <link href="/2018/09/27/errors/"/>
      <url>/2018/09/27/errors/</url>
      <content type="html"><![CDATA[<h1 id="Syntax-Errors"><a href="#Syntax-Errors" class="headerlink" title="Syntax Errors"></a>Syntax Errors</h1><p>Syntax errors, also known as <strong>parsing errors.</strong><br>语法错误，也就是不符合python语法规范，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; while True print(&apos;Hello world&apos;)</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    while True print(&apos;Hello world&apos;)</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这里的while后面少了一个冒号：，解析器会检测到最早的一个错误。</p><h1 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h1><p>Even if a statement of exception is syntactically correct, It may cause an error when an attempt is made to execute it. Errors detected during execution are called <strong>exceptions</strong> and are not unconditionally fatal.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 * (1/0)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">&gt;&gt;&gt; 4 + spam*3</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &apos;spam&apos; is not defined</span><br><span class="line">&gt;&gt;&gt; &apos;2&apos; + 2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly</span><br></pre></td></tr></table></figure><p>The last line of the error message indicates what happened. Excptions come in different types, and the type is printed as part of the message: The type in the example are <strong>ZeroDivisionError, NameError and TypeError</strong>.</p><h1 id="Handling-exceptions"><a href="#Handling-exceptions" class="headerlink" title="Handling exceptions"></a>Handling exceptions</h1><p>It is possible to write programs that handle selected exceptions. Following example, which asks the user for input until a valid integer has been entered.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">   try:</span><br><span class="line">      x = int(input(&quot;Please enter a number:&quot;))</span><br><span class="line">      break</span><br><span class="line">   except ValueError:</span><br><span class="line">      print(&quot;no valid, try aganin:&quot;)</span><br></pre></td></tr></table></figure><p>But allows the user to interrupt the program(Using Control-C or whatever the operating system supports); Note that a user-generated interruption is signalled by rasing the <strong>KeyboardInterrupt</strong> exception.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Please enter a number:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\SongChengjun\Desktop\q.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    x = int(input(&quot;Please enter a number:&quot;))</span><br><span class="line">KeyboardInterrupt</span><br></pre></td></tr></table></figure><p>The <strong>try</strong> statement works as follow:</p><ol><li>First, the <em>try clause</em>(the statement(s)between the <strong>try</strong> and <strong>except</strong> keywords)is executed,</li><li>If no exception occurs, the <em>except clause</em> is skipped and execution of the <strong>try</strong> statement is finished.</li><li>if an exception occurs during execution of the try clause, the rest of the caulse is skipped. Then if its type matches the exception named after the <strong>except</strong> keyword, the except clause is executed, and rhenexdecution continues after the <strong>try</strong> statement.</li><li>if an exception occurs which does not match the exception named in the except caluse, it is passed on the outer <strong>try</strong> statements; if no handler is found, it is an <em>unhandled exception</em> and execution stops with a message as shown above.</li></ol><p>A <strong>try</strong> statement may have more than one except clause. to specify handlers for different exceptions. At most one handler will be executed. Handlers only handle exceptions that occur in the corresponding try clause, not in other handlers of the same try statement. An except clause may name multiple exceptions as a parenthesized tuple, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">except(RuntimeError, TypeError, NameError):</span><br><span class="line">     pass</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记于生日前</title>
      <link href="/2018/09/26/diary1/"/>
      <url>/2018/09/26/diary1/</url>
      <content type="html"><![CDATA[<p><em>毕业了，就这么毕业了。</em></p><p>没有任何多余的想法，只想抓紧进入岗位，抛洒一片热血。</p><hr><p>小学六年，初中三年，高中三年，大学四年，研究生一年，<strong>17年</strong> 学生时代已经彻底翻片儿。27号我将迎来我的第 <strong>23个生日</strong>。现在很多人喜欢叫老，不知道是真觉得老，还是自嘲。</p><h3 id="而我，正值青春。"><a href="#而我，正值青春。" class="headerlink" title="而我，正值青春。"></a>而我，正值青春。</h3><a id="more"></a><p>我当然给自己做了详细的规划，描绘了未来蓝图。我也知道这路上荆棘丛生，险难不断。 <strong>生活嘛，既然想要就得付出。</strong></p><p>我是一个喜欢并且容易暴露缺点的人，不招人喜欢，<strong>性格使然</strong>。偶尔放纵做一些低级趣味。大大咧咧的表面往往造成这个人不学无术的错误印象。 守仁解释曰：<em>人之本体常常是寂然不动的，常常是感而逐通的，未应不是先，已应不是后。</em></p><p>摸爬滚打：凌晨3点起床从曼彻斯特赶车到伯明翰见导师；睡过自习室、车站，连续一个月每天15个小时写代码；毕设9月前要求交稿，6，7两月在国外边实习边做项目，7月完成测试；8月回国白天实习，晚上写报告；8月的南京躁动的热，晚上公司大厅没有空调，我汗流浃背；笔试14份，面试10份；光简历根据不同需要我都做了6份；<em>7，8，9三个月期间可以说有点小付出。</em></p><p>这话我大多朋友都听我讲过，<strong>人生三大财富：健康，朋友，经历。</strong> 走出校园，踏上社会，<strong>我乐观但不盲目，我自信但不自负，我坚持但不刻板。</strong></p><p>接触过得所有人和事， <strong>这一切我兼收并蓄，形成我的个人价值。</strong></p><p><strong>感恩，有太多人需要感谢。</strong> 都只在此心，心即理也。王守仁再曰：以此纯乎天理之心，发之事父便是孝，发之事君便是忠，发之交友，治民便是信与任。譬之树木，年轻人的理想抱负皆是根，许多条件便是枝叶，须先有根，然后又枝叶，不是先寻了枝叶，然后去种根。青年当之，弘我中华！</p><p><strong><em>我是宋大克</em></strong></p><p><em>放一张小时候的帅照：</em></p><p><a href="https://i.loli.net/2018/09/27/5bac18544afef.jpg" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/27/5bac18544afef.jpg" alt="微信图片_20180927073746.jpg"></a></p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关于C语言输入的探究</title>
      <link href="/2018/09/25/C%E8%AF%AD%E8%A8%80%E8%BE%93%E5%85%A5/"/>
      <url>/2018/09/25/C%E8%AF%AD%E8%A8%80%E8%BE%93%E5%85%A5/</url>
      <content type="html"><![CDATA[<p><strong><em>首先需要知道，在C语言中没有字符串类型，用字符数组处理字符串</em></strong></p><p>字符串数组定义： char 数组名[a][b]</p><p>有一维，二维数组，  <em>数组名既是数组名又是这个字符串的首地址</em></p><p>输入输出方法：逐个字符输入输出：<strong>%c</strong>   整个字符串输入输出：<strong>%s</strong></p><a id="more"></a><hr><h1 id="scanf-输入printf-输出"><a href="#scanf-输入printf-输出" class="headerlink" title="scanf()输入printf()输出"></a>scanf()输入printf()输出</h1><p><strong>逐个字符处理：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char ch[5];</span><br><span class="line">for (int i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%c&quot;, &amp;ch[i]);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%c&quot;, ch[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p><strong>整个字符串处理：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char ch[5];</span><br><span class="line">scanf(&quot;%s&quot;, ch); //无需&amp; 对于数组ch，就是首地址所以不需要取地址符</span><br><span class="line">printf(&quot;%s&quot;, ch);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><br>以字符串为单位处理时，<em>直接使用数组名，</em> 不需要加&amp;<br>输入字符串时，字符个数要小于数组的长度，例如输入5个字符，定义的字符数组至少应该有6个。<br>输入字符串时，遇到回车或者空格，输入结束，并且自动在串后面加上结束标志’\0’<br>输出字符串时，遇到字符串结束标志”\0”，输出结束</p><p>scanf()配合%s使用，但是这种方法一次只能获取一个单词，即遇到空格等字符就会返回。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i love you</span><br></pre></td></tr></table></figure></p><p>输出为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure></p><h2 id="scanf就无能无力，但是我们可以用gets"><a href="#scanf就无能无力，但是我们可以用gets" class="headerlink" title="scanf就无能无力，但是我们可以用gets()"></a><strong><em>scanf就无能无力，但是我们可以用gets()</em></strong></h2><h1 id="gets-和-puts-在-lt-string-h-gt-头文件中"><a href="#gets-和-puts-在-lt-string-h-gt-头文件中" class="headerlink" title="gets() 和 puts() 在&lt;string.h&gt;头文件中"></a>gets() 和 puts() 在&lt;string.h&gt;头文件中</h1><h3 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h3><p>向显示器输出字符串（输出结束，自动换行，即用’\n’代替’\0’)<br>字符串数组必须以’\0’结束</p><h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h3><p>gets()函数用来从标准输入设备（键盘）读取字符串直到 <strong>换行符</strong> 结束，但是换行符会被丢弃，然后再末尾添加 <strong>“\0”</strong> 字符。<br>gets()读完结束后系统 <strong>自动会将’\n’置换成’\0’</strong><br>调用格式： gets(s)<br>其中s为字符串变量（字符串数组名或者字符串指针）。以回车结束，自动加’\0’.<br>输入串长度应小于字符数组维数，字符串中可以包含空格</p><p>gets()函数与scanf(“%s:”,&amp;s)/<em>scanf(“%s”,s)</em>/相似,但不完全相同，使用scanf(“%s”,&amp;s)函数输入字符串时存在一个问题，如果输入了 <strong>空格</strong> 会以为字符串结束，空格后的字符将作为下一个输入项处理，但gets()函数将接收整个字符串直到遇到换行为止。</p><p><strong>不同点</strong></p><ol><li>scanf不能接受空格、制表符Tab、回车等；而gets可以</li></ol><p><strong>相同点</strong></p><ol><li>字符串接受结束后 <strong>自动加’\0’</strong></li></ol><h3 id="gets-存在严重缺陷：它不会检测数组能否装的下输入行"><a href="#gets-存在严重缺陷：它不会检测数组能否装的下输入行" class="headerlink" title="gets()存在严重缺陷：它不会检测数组能否装的下输入行"></a>gets()存在严重缺陷：它不会检测数组能否装的下输入行</h3><p>比如定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char src[5];</span><br></pre></td></tr></table></figure></p><p><em>数组名就相当于一个指针，也就是数组的首地址。</em></p><p>如果我们输入的字符大于5，填满这5个空间后，gets()函数就会访问 <em>未被分配</em> 的内存空间，如果这片空间 <em>已经有数据，</em> 这时程序就会发生错误，而中断。<br>C99y不建议使用，C11直接抛弃。</p><p>建议使用fgets()函数来代替gets()</p><p>函数声明： char <em>fgets(char </em>buf, int bufsize, FILE <em>stream)</em>；</p><p>注意第二个参数 <strong>bufsize</strong>, 这个参数就限制了读取的字符的个数，这就可以解决gets()函数的缺陷。</p><p>fgets()函数主要用于 <strong>读取文件</strong>， 如果要读取键盘，则stream参数应该为 <strong>stdin</strong>.<br>需要注意的是，如果bufsize设置为n, 那么fgets()函数最多读取 <strong>n-1</strong> 个字符（包括最后的 <strong>‘\n’</strong>，读完结束后系统将自动在最后加 <strong>‘\0’</strong> 为什么说“最多”，那是因为如果在之前遇到了换行符，fgets()函数也会返回。<br>还有一点，fgets()不会自动添加换行，但是可以读取换行符。</p><p><strong><em>注意：</em></strong><br>在使用fgets的时候，预设了size为N，这个时候我们最多能读取的字符串个数为N-1，剩下的会用新的fgets()来读取，看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">char str2[10];</span><br><span class="line">fgets(str2,3,stdin);</span><br><span class="line">printf(&quot;First 2 str: %s\n&quot;,str2);</span><br><span class="line">printf(&quot;The length of str is: %d\n&quot;,strlen(str2));</span><br><span class="line">fgets(str2,3,stdin);</span><br><span class="line">printf(&quot;The left str: %s\n&quot;,str2);</span><br><span class="line">printf(&quot;The length of str is: %d\n&quot;,strlen(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出为：</p><p><img src="https://i.loli.net/2018/09/19/5ba1cefd26690.png" alt="输出结果"></p><p>当使用gets(),输入字符串是多少个，就会输出多少个字符串，需要注意输入的字符串个数不能&gt;N,超过的部分会存在新的内存，如果那片内存有数据就会中断程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">char str2[3];</span><br><span class="line">gets(str2);</span><br><span class="line">printf(&quot;str: %s\n&quot;,str2);</span><br><span class="line">printf(&quot;The length of str is: %d\n&quot;,strlen(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果为：</p><p><img src="https://i.loli.net/2018/09/20/5ba3982798aff.png" alt="微信截图_20180919122655.png](https://i.loli.net/2018/09/20/5ba3982798aff.png)"></p><p>两种新情况：</p><ol><li><p>当从键盘上输入 <strong>&lt;=N-1</strong> 个字符（包括  <strong>‘\n’</strong> ）时，那么字符串str会以 <strong>‘\n\0’</strong> 结尾，这就造成了strlen(str)比预计的大1，可以利用下面的代码将’\n’去掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(str[strlen(str)-1] == &apos;\n&apos;)</span><br><span class="line">&#123;</span><br><span class="line">str[strlen(str)-1] = &apos;\0&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当从键盘上输入 <strong>&gt;N-1</strong> 个字符（包括’\n’)时，那么字符串会以 <strong>‘\0’</strong> 结尾。</p></li></ol><p>再详细说明一下，输入字符大于N的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 5</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char s1[N];</span><br><span class="line">    char s2[N];</span><br><span class="line">    fgets(s1, N, stdin);</span><br><span class="line">//    gets(s1);</span><br><span class="line">    if(s1[strlen(s1) - 1] == &apos;\n&apos;) &#123;      // 去掉换行符</span><br><span class="line">        s1[strlen(s1) - 1] = &apos;\0&apos;;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    fflush(stdin);                               //清空缓冲区</span><br><span class="line">    fgets(s2, N, stdin);</span><br><span class="line">//    gets(s2);</span><br><span class="line">    if(s2[strlen(s2) - 1] == &apos;\n&apos;) &#123;      // 去掉换行符</span><br><span class="line">        s2[strlen(s2) - 1] = &apos;\0&apos;;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%s %s&quot;, s1, s2);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12345</span><br><span class="line">1234 5</span><br></pre></td></tr></table></figure></p><p>也就是说S1=1234， S2=5，第一个fgets只读取了1234，因为最多读取N-1个数。剩下 <strong>5’\n’</strong> 被放入了缓冲区，当程序运行到第二个fgets的时候会直接读取缓冲区的数据，直到遇到 <strong>‘\n’</strong> .此时 <strong>s1=1234’\0’</strong>, <strong>s2=5’\0’</strong>.<br>这个时候，我可以在第二个fgets前加一句 <strong>fflush(stdin)</strong>， 起到清除缓冲区的作用，后面就不会输出5了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12345</span><br><span class="line"></span><br><span class="line">1234</span><br></pre></td></tr></table></figure></p><p>在读取完s1之后，利用 <strong>fflush(stdin)</strong> 清除缓冲区。</p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中strings &amp; lists, end关键字和循环语句</title>
      <link href="/2018/09/25/python/"/>
      <url>/2018/09/25/python/</url>
      <content type="html"><![CDATA[<h1 id="Escape-quote-“”-and-‘’"><a href="#Escape-quote-“”-and-‘’" class="headerlink" title="Escape quote(“” and ‘’)"></a>Escape quote(“” and ‘’)</h1><p><strong>‘’</strong> and <strong>“”</strong> are the same used in python<br>two ways to escape quotes:</p><p>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;doesn\&apos;t&apos;  # use \&apos; to escape the single quote...</span><br><span class="line">&quot;doesn&apos;t&quot;</span><br></pre></td></tr></table></figure></p><p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;doesn&apos;t&quot;  # ...or use double quotes instead</span><br><span class="line">&quot;doesn&apos;t&quot;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h1><p>Which can be expressed in several ways:</p><ol><li>enclosed in sigle quotes <em>‘’</em></li><li>enclosed in double quotes <em>“”</em><br><em>\</em> can be used to escape quotes<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---+---+---+---+---+---+</span><br><span class="line">| P | y | t | h | o | n |</span><br><span class="line">+---+---+---+---+---+---+</span><br><span class="line">0   1   2   3   4   5   6</span><br><span class="line">-6  -5  -4  -3  -2  -1</span><br></pre></td></tr></table></figure></li></ol><p><strong><em>Notice:</em></strong> Python string cannot be changed, they are <strong>immutable</strong><br>if we need a different string, creating a new one.</p><p> <strong>len()</strong> is a built-in function returns the length of a string</p><h1 id="lists"><a href="#lists" class="headerlink" title="lists"></a>lists</h1><p>Lists might contain items of different types, but usually the items all have the same types.<br>can be <em>sliced</em> and <em>indexed</em><br>all slice operations return a new list. (Return a new list)</p><p>Unlike strings, whihc are immutable, lists are a <strong>mutable</strong> type. The content of it can be changed.</p><p> append() adding new item at the end of the list</p><p> Assignment to slices can change the size of the list or clear it entirely:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &gt;&gt;&gt; letters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;]</span><br><span class="line">&gt;&gt;&gt; letters</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;]</span><br><span class="line">&gt;&gt;&gt; # replace some values</span><br><span class="line">&gt;&gt;&gt; letters[2:5] = [&apos;C&apos;, &apos;D&apos;, &apos;E&apos;]</span><br><span class="line">&gt;&gt;&gt; letters</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;f&apos;, &apos;g&apos;]</span><br><span class="line">&gt;&gt;&gt; # now remove them</span><br><span class="line">&gt;&gt;&gt; letters[2:5] = []</span><br><span class="line">&gt;&gt;&gt; letters</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;f&apos;, &apos;g&apos;]</span><br><span class="line">&gt;&gt;&gt; # clear the list by replacing all the elements with an empty list</span><br><span class="line">&gt;&gt;&gt; letters[:] = []</span><br><span class="line">&gt;&gt;&gt; letters</span><br></pre></td></tr></table></figure></p><p>len() also applies to lists.</p><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>end is the keyword argument can be used to avoid the newline after the output, or end the output with a different string:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b = 0,1</span><br><span class="line">&gt;&gt;&gt; while b&lt;1000:</span><br><span class="line">print(b)</span><br><span class="line">a,b = b,a+b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">55</span><br><span class="line">89</span><br><span class="line">144</span><br><span class="line">233</span><br><span class="line">377</span><br><span class="line">610</span><br><span class="line">987</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a,b = 0,1</span><br><span class="line">&gt;&gt;&gt; while b &lt; 1000:</span><br><span class="line">print(b,end=&apos;,&apos;)</span><br><span class="line">a,b = b,a+b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,</span><br></pre></td></tr></table></figure><h1 id="for-statement"><a href="#for-statement" class="headerlink" title="for statement"></a>for statement</h1><p>python for statement iterates over the items of any sequence(a list or strings), in the order that they appear in the sequence.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; # Measure some strings:</span><br><span class="line">... words = [&apos;cat&apos;, &apos;window&apos;, &apos;defenestrate&apos;]</span><br><span class="line">&gt;&gt;&gt; for w in words:</span><br><span class="line">...     print(w, len(w))</span><br><span class="line">...</span><br><span class="line">cat 3</span><br><span class="line">window 6</span><br><span class="line">defenestrate 12</span><br></pre></td></tr></table></figure></p><p>when we want to midify the sequence we are iterating over while inside the loop. It is crucial we make a copy. Iterating over a sequence does not implicitly make a copy. The <strong>slice notation</strong> makes this especially convenient.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for w in words[:]:  # Loop over a slice copy of the entire list.</span><br><span class="line">...     if len(w) &gt; 6:</span><br><span class="line">...         words.insert(0, w)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; words</span><br><span class="line">[&apos;defenestrate&apos;, &apos;cat&apos;, &apos;window&apos;, &apos;defenestrate&apos;]</span><br></pre></td></tr></table></figure></p><p>With for w in words:, the example would attempt to create an infinite list, inserting defenestrate over and over again.</p><p><strong><em>notice:</em></strong> We need slice notation for a <strong>copy</strong> of string or lists when we want to <strong>manipulate</strong> the sequence.</p><h1 id="while-statement"><a href="#while-statement" class="headerlink" title="while statement"></a>while statement</h1><p>we need to set a break after the excution code within the while statement, otherwise, it will generate a infinite loop.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while 1:</span><br><span class="line">    print(1)</span><br><span class="line">    break       #stop the excution</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈python的module以及if __name__ == __main__的理解</title>
      <link href="/2018/09/25/module/"/>
      <url>/2018/09/25/module/</url>
      <content type="html"><![CDATA[<p><em>模块化理解</em></p><h1 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h1><p>A module is <strong>a file</strong> containing Python definitions and statements. (suffix .py is the file name and also the module name)<br>Within a module, the module name(as a string) is available as the value of the global variable <strong><em>name</em></strong></p><p>if we only import the module name:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>In this way, we can not use the fuctions defined in sys directly, but, we are allowed to access the functions by using module name:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.ppp()</span><br><span class="line">sys.ooo()</span><br></pre></td></tr></table></figure></p><p>we need module name before functions.</p><p>Additionaly, if we intend to use a function often, we can assign it to a local name:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ppp = sys.ppp</span><br><span class="line">ppp()</span><br></pre></td></tr></table></figure></p><h1 id="More-on-Modules"><a href="#More-on-Modules" class="headerlink" title="More on Modules"></a>More on Modules</h1><p>Modules can import other modules.<br>The imported module names are placed in the importing module global symbol table.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from fibo import fib,fib2</span><br></pre></td></tr></table></figure></p><p>On this condition, module name is not defined, it is not introduced. And we know the functions which we will use in the module.</p><p>There is even a variant to import all names that a module defines:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from fibo import *</span><br></pre></td></tr></table></figure></p><p>in most cases python programmers do not use this facility since it introduces an unknow set of names into the interpreter, possibly hiding some things you have already defined.<br>Additionally, it cause unreadable code.</p><h1 id="executing-modules-as-scripts"><a href="#executing-modules-as-scripts" class="headerlink" title="executing modules as scripts"></a>executing modules as scripts</h1><p>when we run a python module Within<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python fibo.py&lt;arguments&gt;</span><br></pre></td></tr></table></figure></p><p>the code in the module will be executed, just as if you imported it, but with the <strong><strong>mame</strong></strong> set to <strong>“<strong>main</strong>“</strong>. By adding this code at the end of your module:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    import sys</span><br><span class="line">    fib(int(sys.argv[1]))</span><br></pre></td></tr></table></figure></p><p>you can make the file usable as a script as well as an importable module., because the code that parses the command line only runs if the module is executed as the main file:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python fibo.py 50</span><br><span class="line">1 1 2 3 5 8</span><br></pre></td></tr></table></figure></p><p>if the module is imported, the code is not run:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import fibo</span><br></pre></td></tr></table></figure></p><p>this is often used either to provide a convenient <strong>user interface</strong> to a module, or for testing purposes(running the module as a script executes a test suite)</p><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>像c,c++都有一个 <strong>main函数</strong> 作为程序的入口，程序的运行会从main开始。<br>python则不同，它属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。从脚本第一行开始运行，没有同统一的入口。</p><p>一个python源码文件除了可以被直接运行外，还可以作为模块（也就是库）被导入。不管是直接运行还是导入，最顶层的代码都会被运行（python用缩进来区分代码层次）。而事实上，有一部分代码我不希望被运行。</p><p>现在我有一个q.py文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PI = 3.14</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;PI:&quot;,PI)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><p>还有一个test.py文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from q import PI</span><br><span class="line"></span><br><span class="line">def cal(r):</span><br><span class="line">    return PI * ( r ** 2)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;area:&quot;,cal(2))</span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><p>在test.py里我导入了q.py中的PI值，现在我运行test.py输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PI: 3.14</span><br><span class="line">area: 12.56</span><br></pre></td></tr></table></figure></p><p>我不想输出PI啊，只需要area就好，因为在运行test.py时候，所有包含的文件都会被运行。这个时候，if <strong>__</strong>name__ == ‘<strong>__</strong>main__’ 就派上用场了。把q.py改一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PI = 3.14</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;PI:&quot;,PI)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>然后再运行test.py,结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area: 12.56</span><br></pre></td></tr></table></figure></p><p>终于达到了想要的结果。</p><p>if <strong>__</strong>name__ == ‘<strong>__</strong>main__’就相当于 <strong>python模拟的程序入口。</strong> 主要注意的是，python本身并没有规定这么写，这只是一种编码习惯。总的来说，由于模块之间相互引用，不同模块可能都有这样的定义。到底哪个入口程序被选中，这取决于 <strong>__</strong>name__ 的值</p><h2 id="name"><a href="#name" class="headerlink" title="__name__"></a><strong>__</strong>name__</h2><p><strong>__</strong>name__是内置变量，用于表示当前模块的名字。同时还能反映一个包的结构。</p><p>如果模块被直接运行，则代码块被运行；如果模块是被导入的，则代码块不被运行。</p><h1 id="The-module-search-path"><a href="#The-module-search-path" class="headerlink" title="The module search path"></a>The module search path</h1><p>When a module named <strong>spam</strong> is imported, the interpreter first searches for a built-in module with that name. If not found, it then search for a file named <strong>spam.py</strong> in a list of directories given by the variable <strong>sys.path</strong>, <strong>sys.path</strong> is initialized from these locations.</p><ol><li>The directory containing the input script (or the current directory when no file is specified)</li><li><strong>PYTHONPATH</strong> (a list of directory names, with the same syntax as the shell variable <strong>PATH</strong>)</li><li>The installation-dependent default.</li></ol><h1 id="The-dir-function"><a href="#The-dir-function" class="headerlink" title="The dir() function"></a>The <strong>dir()</strong> function</h1><p>The built-in function <strong>dir()</strong> is used to find out which names a module defines. It returns a sorted list of strings.<br><strong>dir()</strong> does not list the names of built-in functions and variables. If you want a list of those, they are defined in the standard module <strong>builtins</strong>.</p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈Tuple &amp; Dictionary以及loop的几种方法</title>
      <link href="/2018/09/25/tuple/"/>
      <url>/2018/09/25/tuple/</url>
      <content type="html"><![CDATA[<h1 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h1><p><strong>tuple</strong> is another sequence data type.</p><p>A tuple consists of a number of values separated by commas.<br>They may be input with or without parenthess.<br>It is not possible to assign to the indivdual items of a tuple, however it is possible to create tuples which contain mutable objects, such as list.</p><p>tuples are <strong>immutable</strong><br>lists are <strong>mutable</strong><br><a id="more"></a></p><h1 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h1><p>unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by <strong>keys</strong>, which can be any immutable type; <em>strings</em> and <em>numbers</em> can always be keys.</p><p>list(d.keys()) returns a list of all the keys used in the dictionary, in arbitrary order (we can use sorted(d.keys())) to sort it). To check whether a single key is in the dictionary use the <strong>in</strong> keyword</p><h2 id="looping-technique"><a href="#looping-technique" class="headerlink" title="looping technique"></a>looping technique</h2><p><em>when looping through dictionaires</em>, the key and correspinding value can be retrieved at the same time using the <strong>items()</strong> method.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; knights = &#123;&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; for k, v in knights.items():</span><br><span class="line">...     print(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure></p><p><em>When looping through a sequence</em>, the position index and corresponding value can be retrieved at the same time using the <strong>enumerate()</strong> function. 这是一个内置函数哦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, v in enumerate([&apos;tic&apos;, &apos;tac&apos;, &apos;toe&apos;]):</span><br><span class="line">...     print(i, v)</span><br><span class="line">...</span><br><span class="line">0 tic</span><br><span class="line">1 tac</span><br><span class="line">2 toe</span><br></pre></td></tr></table></figure></p><p>如果不用enumerate，普通的for语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">i=0</span><br><span class="line">for element in a:</span><br><span class="line">   print(i,element)</span><br><span class="line">   i = i + 1</span><br></pre></td></tr></table></figure></p><p><em>To loop over two or more sequences at the same time</em>, the entries can be paired with the <strong>zip()</strong> function.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; questions = [&apos;name&apos;, &apos;quest&apos;, &apos;favorite color&apos;]</span><br><span class="line">&gt;&gt;&gt; answers = [&apos;lancelot&apos;, &apos;the holy grail&apos;, &apos;blue&apos;]</span><br><span class="line">&gt;&gt;&gt; for q, a in zip(questions, answers):</span><br><span class="line">...     print(&apos;What is your &#123;0&#125;?  It is &#123;1&#125;.&apos;.format(q, a))</span><br><span class="line">...</span><br><span class="line">What is your name?  It is lancelot.</span><br><span class="line">What is your quest?  It is the holy grail.</span><br><span class="line">What is your favorite color?  It is blue.</span><br></pre></td></tr></table></figure></p><p><em>To loop over a sequence in reverse</em>, first specify the sequence in a forward direction and then call the reversed() function.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):</span><br><span class="line">...     print(i)</span><br><span class="line">...</span><br><span class="line">9</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p><em>To loop over a sequence in sorted order</em>, use the sorted() function which returns a new sorted list while leaving the source unaltered.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; basket = [&apos;apple&apos;, &apos;orange&apos;, &apos;apple&apos;, &apos;pear&apos;, &apos;orange&apos;, &apos;banana&apos;]</span><br><span class="line">&gt;&gt;&gt; for f in sorted(set(basket)):</span><br><span class="line">...     print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure></p><h1 id="more-on-conditions"><a href="#more-on-conditions" class="headerlink" title="more on conditions"></a>more on conditions</h1><p><strong>in</strong> and <strong>not in</strong> check whether a value occurs(does not occur) in a sequence.<br><strong>is</strong> and <strong>is not</strong> compare whether two objects are really the same object<br>this only matters for mutable objects like lists.</p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python列表的相关函数</title>
      <link href="/2018/09/25/list/"/>
      <url>/2018/09/25/list/</url>
      <content type="html"><![CDATA[<p><strong>list.append(x)</strong><br>add an item to the end of the list. Equivalent to a[len(a):]=[x]<br>in a list, the last item can be indexed as a[len(a)-1]<br>When we want to add an item at the last, a[len(a):] = [] wil creat a eampt list a[len(a)]<br>Additinally we need to notice the [x] it should be a list</p><p><strong>list.extend(iterable)</strong><br><a id="more"></a><br>append only one value, extend can append servral values.<br><figure class="highlight plain"><figcaption><span>a</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 2, 3, 555]</span><br><span class="line">&gt;&gt;&gt; b = [45,56565,56565,5656565,]</span><br><span class="line">&gt;&gt;&gt; a.extend(b)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 2, 3, 2, 3, 555, 45, 56565, 56565, 5656565]</span><br></pre></td></tr></table></figure></p><p><strong>list.insert(i,x)</strong><br>insert an item at a given position<br>The i is the index of the element before which to insert.<br>a.insert(0,x) inserts at the front of the lists<br>a.insert(len(a),x) is equivalent to a.append(x)<br>insert index from 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 2, 3, 2, 3, 555, 45, 56565, 56565, 5656565]</span><br><span class="line">&gt;&gt;&gt; a.insert(3,8)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 2, 3, 8, 2, 3, 555, 45, 56565, 56565, 5656565]</span><br></pre></td></tr></table></figure></p><p><strong>list.remove(x)</strong><br>remove the first item from the list whose value is x.</p><p><strong>list.pop([i])</strong><br>remove the item at the given position in the list, and return it. If no idex is soecified, a.pop() removes and return the last item in the list.<br>pop index from 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[22, 2, 3, 8, 2, 3, 555, 45, 56565, 56565]</span><br><span class="line">&gt;&gt;&gt; a.pop(2)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[22, 2, 8, 2, 3, 555, 45, 56565, 56565]</span><br></pre></td></tr></table></figure></p><p>pop returns a value, del no return</p><p><strong>list.clear()</strong><br>remove all items from the list. Equivalent to del a[:]</p><p><strong>list.count(x)</strong><br>return the number of times x appears in the list</p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>set() &amp; sort() &amp; sorted() &amp; range() &amp; break &amp; continue</title>
      <link href="/2018/09/25/set/"/>
      <url>/2018/09/25/set/</url>
      <content type="html"><![CDATA[<h1 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h1><p>创建一个 <strong>无序不重复</strong> 元素集，可以进行关系测试，删除重复数据，还可以计算交集，差集、并集等。set不记录元素位置或者插入点，不支持index, slice。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;x = set(&apos;runoob&apos;)</span><br><span class="line">&gt;&gt;&gt; y = set(&apos;google&apos;)</span><br><span class="line">&gt;&gt;&gt; x, y</span><br><span class="line">(set([&apos;b&apos;, &apos;r&apos;, &apos;u&apos;, &apos;o&apos;, &apos;n&apos;]), set([&apos;e&apos;, &apos;o&apos;, &apos;g&apos;, &apos;l&apos;]))   # 重复的被删除</span><br><span class="line">&gt;&gt;&gt; x &amp; y         # 交集</span><br><span class="line">set([&apos;o&apos;])</span><br><span class="line">&gt;&gt;&gt; x | y         # 并集</span><br><span class="line">set([&apos;b&apos;, &apos;e&apos;, &apos;g&apos;, &apos;l&apos;, &apos;o&apos;, &apos;n&apos;, &apos;r&apos;, &apos;u&apos;])</span><br><span class="line">&gt;&gt;&gt; x - y         # 差集</span><br><span class="line">set([&apos;r&apos;, &apos;b&apos;, &apos;u&apos;, &apos;n&apos;])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h1 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h1><p>用于对元列表进行排序<br>list.sort(cmp=none, key=none, reverse=False)<br>cmp – 可选参数，如果指定了该参数会使用该参数的方法进行排序。<br>key –用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。<br>reverse是排序规则，reverse=True降序，reverse=False升序（默认）</p><p><strong>notice:需要注意的是，sort的目标不能交叉，要不都是数字要不都是字符串</strong></p><h1 id="sort-与-sorted-区别"><a href="#sort-与-sorted-区别" class="headerlink" title="sort 与 sorted 区别"></a>sort 与 sorted 区别</h1><p><em>sort</em> 是应用在<em>list</em>上的方法，<em>sorted</em> 可以对所有可迭代的对象进行排序操作<br><em>list</em> 的 <em>sort</em> 方法返回的是已经存在的列表进行操作，无返回值，而内建函数sorted方法返回的是一个新的list, 而不是在原来的基础上进行操作。</p><h1 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h1><p>sorted(iterable[, cmp[, key[, reverse]]])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [5,7,6,3,4,1,2]</span><br><span class="line">&gt;&gt;&gt; b = sorted(a)       # 保留原列表</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[5, 7, 6, 3, 4, 1, 2]</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure></p><h1 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h1><p><strong>iterate over a sequence of numbers</strong><br>it is a built-in function<br>it generates arithmetic progressions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i in range(5):</span><br><span class="line">    print(i)</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p><p><strong><em>Notice:</em></strong> range(5) end with 4 not 5, because it index from 0<br>we can also set the start and end value within range(start, end)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">range(5,10)</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><p>Additionally, we can also set the step size, range(start, end, stepsize)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">range（0，10，3)</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><p>to iterate over the indices of a sequence, we can combine range() and len()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [&apos;Mary&apos;, &apos;had&apos;, &apos;a&apos;, &apos;little&apos;, &apos;lamb&apos;]</span><br><span class="line">    for i in range(len(a)):</span><br><span class="line">...     print(i, a[i])</span><br><span class="line">...</span><br><span class="line">0 Mary</span><br><span class="line">1 had</span><br><span class="line">2 a</span><br><span class="line">3 little</span><br><span class="line">4 lamb</span><br></pre></td></tr></table></figure></p><h1 id="break-and-continue-Statements-and-else-Clauses-on-Loops"><a href="#break-and-continue-Statements-and-else-Clauses-on-Loops" class="headerlink" title="break and continue Statements, and else Clauses on Loops"></a><strong>break</strong> and <strong>continue</strong> Statements, and <strong>else</strong> Clauses on Loops</h1><p>like in C, breaks out of the innernost enclosing <strong>for</strong> or <strong>while</strong> loop.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in range(2, 10):</span><br><span class="line">...     for x in range(2, n):</span><br><span class="line">...         if n % x == 0:</span><br><span class="line">...             print(n, &apos;equals&apos;, x, &apos;*&apos;, n//x)</span><br><span class="line">...             break</span><br><span class="line">...     else:</span><br><span class="line">...         # loop fell through without finding a factor</span><br><span class="line">...         print(n, &apos;is a prime number&apos;)</span><br><span class="line">...</span><br><span class="line">2 is a prime number</span><br><span class="line">3 is a prime number</span><br><span class="line">4 equals 2 * 2</span><br><span class="line">5 is a prime number</span><br><span class="line">6 equals 2 * 3</span><br><span class="line">7 is a prime number</span><br><span class="line">8 equals 2 * 4</span><br><span class="line">9 equals 3 * 3</span><br></pre></td></tr></table></figure></p><p><strong><em>notice:</em></strong> the <em>else</em> clause belongs to the <em>for</em> loop<br>when used with a loop, the <em>else</em> clause has more in common with the <em>else</em> clause of a <em>try</em> statement than it does that of <em>if</em> statements: a <em>try</em> statement <em>else</em> clause runs when no exception occurs, and a loop <em>else</em> clause runs when no <em>break</em> occurs.</p><p><em>continue</em> with the next iteration of the loop:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for num in range(2, 10):</span><br><span class="line">...     if num % 2 == 0:</span><br><span class="line">...         print(&quot;Found an even number&quot;, num)</span><br><span class="line">...         continue</span><br><span class="line">...     print(&quot;Found a number&quot;, num)</span><br><span class="line">Found an even number 2</span><br><span class="line">Found a number 3</span><br><span class="line">Found an even number 4</span><br><span class="line">Found a number 5</span><br><span class="line">Found an even number 6</span><br><span class="line">Found a number 7</span><br><span class="line">Found an even number 8</span><br><span class="line">Found a number 9</span><br></pre></td></tr></table></figure></p><p>if we do not use continue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for num in range(2, 10):</span><br><span class="line">...     if num % 2 == 0:</span><br><span class="line">...         print(&quot;Found an even number&quot;, num)</span><br><span class="line">...     print(&quot;Found a number&quot;, num)</span><br><span class="line">Found an even number 2</span><br><span class="line">Found a number 3</span><br><span class="line">Found a number 3</span><br><span class="line">Found an even number 4</span><br><span class="line">Found a number 5</span><br><span class="line">Found a number 5</span><br><span class="line">Found an even number 6</span><br><span class="line">Found a number 7</span><br><span class="line">Found a number 7</span><br><span class="line">Found an even number 8</span><br><span class="line">Found a number 9</span><br><span class="line">Found a number 9</span><br></pre></td></tr></table></figure></p><p>which means once meet the <em>if</em> requirements, directly start from the iteration, and do not excute the rest code.</p><h1 id="pass-statements"><a href="#pass-statements" class="headerlink" title="pass statements"></a>pass statements</h1><p>it does nothing. It can be used when a statement is required syntactically but the program requires no action. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     pass  # Busy-wait for keyboard interrupt</span><br></pre></td></tr></table></figure></p><p>This is commonly used for creating minimal classes:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyEmptyClass:</span><br><span class="line">...     pass</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>using in place hoder for a function or conditional body. The <em>pass</em> is silently ignored:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def initlog(*args):</span><br><span class="line">...     pass   # Remember to implement this!</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>when i did testing i found an interesting thing:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for num in range(5):</span><br><span class="line">    if num%2 ==0:</span><br><span class="line">        print(&quot;number&quot;,num)</span><br><span class="line">    pass    </span><br><span class="line">    print(&quot;error&quot;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">number 0</span><br><span class="line">error</span><br><span class="line">error</span><br><span class="line">number 2</span><br><span class="line">error</span><br><span class="line">error</span><br><span class="line">number 4</span><br><span class="line">error</span><br></pre></td></tr></table></figure><p>but when i change <em>if</em> to <em>while</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for num in range(5):</span><br><span class="line">    while num%2 ==0:</span><br><span class="line">        print(&quot;number&quot;,num)</span><br><span class="line">    pass    </span><br><span class="line">    print(&quot;error&quot;)</span><br></pre></td></tr></table></figure></p><p>the program run into infinite Loop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number 0</span><br><span class="line">number 0</span><br><span class="line">number 0</span><br></pre></td></tr></table></figure></p><p><strong><em>hehe, actually, not pass it will be into loop as well, just because once the while is true it keep running.</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while 1:</span><br><span class="line">   print(&quot;This is a infinite loop&quot;)</span><br><span class="line">print(&quot;error&quot;)</span><br></pre></td></tr></table></figure></p><p>in fact, once while true it runs the code whinin while infinitely, all the rest codes without while will not run. To stop thr while, just wait for the requirements false.</p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python的format() &amp; string conversion(repr()&amp;str())</title>
      <link href="/2018/09/25/inputandoutput/"/>
      <url>/2018/09/25/inputandoutput/</url>
      <content type="html"><![CDATA[<p>More control over formatting of the output than simply printing space-separated values.</p><p>Using <strong>formatted string literals</strong>, or the <strong>str.format()</strong> method.</p><h2 id="str-format"><a href="#str-format" class="headerlink" title="str.format()"></a>str.format()</h2><p>此函数可以快速处理各种字符串<br>它通过 <strong>{}</strong> 和 <strong>：</strong> 代替 <strong>%</strong></p><ol><li><p>通过字典来设置参数的话，需要在字典名前加两个**</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import string</span><br><span class="line"></span><br><span class="line">site = &#123;&quot;name&quot;:&quot;www&quot;&#125;   #需要注意字典的索引名也需要加双引号哦</span><br><span class="line">print(&quot;网站名:&#123;name&#125;&quot;.format(**site))</span><br></pre></td></tr></table></figure></li><li><p>通过列表索引设置参数</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import string</span><br><span class="line"></span><br><span class="line">site = [&quot;www&quot;,&quot;problem&quot;]</span><br><span class="line">print(&quot;网站名:&#123;0[0]&#125;,地址:&#123;0[1]&#125;&quot;.format(site))</span><br></pre></td></tr></table></figure><p>列表的话就需要指定位置了。</p><p>The <strong>string</strong> module contains a <strong>Template</strong> class which offers yet another way substitute values into strings.</p><p><em>Questions: How do you convert values to strings?</em><br>Luckily, Python has ways to convert any value to a string: pass it to the <strong>repr()</strong> or <strong>str()</strong> functions.</p><p><strong>str()</strong> function is meant to return representations of values which are fairly <strong>human-readable</strong> , while <strong>repr()</strong> is meant to generate representations which can be <strong>read by the interpreter.</strong><br>For human consumption, <strong>str()</strong> will return the same value as <strong>repr()</strong>. Many values, such as numbers or structures like <strong>lists</strong> and <strong>dictionaires</strong>, have the same representations using either function. Strings, in particular, have two distinct representations.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; test = &quot;nihao&quot;</span><br><span class="line">&gt;&gt;&gt; str(test)</span><br><span class="line">&apos;nihao&apos;</span><br><span class="line">&gt;&gt;&gt; repr(test)</span><br><span class="line">&quot;&apos;nihao&apos;&quot;</span><br></pre></td></tr></table></figure><p>list和dictionaire输出都是一样的，在外面加了个双引号<br>但是至于string,str直接单引号，而repr单引号外套双引号。这是两者不同。</p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>EOF问题</title>
      <link href="/2018/09/25/eof/"/>
      <url>/2018/09/25/eof/</url>
      <content type="html"><![CDATA[<p>先看一道字符串的题目：<br>求字符串最后一个单词的长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     char str[5000];</span><br><span class="line">     int i,j=0,N=0;</span><br><span class="line">     while(scanf(&quot;%c&quot;, &amp;str[j])!=EOF)</span><br><span class="line">     &#123;</span><br><span class="line">         if(str[j]==&apos; &apos;)</span><br><span class="line">             N=0;</span><br><span class="line">         else</span><br><span class="line">             N++;</span><br><span class="line">         if(j&lt;4999)</span><br><span class="line">             j++;</span><br><span class="line">     &#125;</span><br><span class="line">     if(N!=0)</span><br><span class="line">         N=N-1;      //为啥减一，因为字符串以\0结尾哦，要注意！！！</span><br><span class="line">     printf(&quot;%d&quot;,N);</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>在while里有个EOF，作为 <strong>读取结束</strong> 标志，来探究一下EOF：<br>C语言中，EOF常被作为文件结束的标志。在while循环中以EOF作为文件结束标志。</p><p><strong>linux系统下，</strong> 在输入回车换行后的空行位置，按 <strong>ctrl+d</strong> (先按ctrl键，不放，再按d键）</p><p><strong>windows系统下，</strong> 在输入回车换行后的空行位置，按 <strong>ctrl+z</strong>，再回车确认</p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FP Presentation Structure</title>
      <link href="/2018/08/30/presentation/"/>
      <url>/2018/08/30/presentation/</url>
      <content type="html"><![CDATA[<h1 id="Presentation-Structure"><a href="#Presentation-Structure" class="headerlink" title="Presentation Structure"></a>Presentation Structure</h1><h2 id="The-Background"><a href="#The-Background" class="headerlink" title="The Background"></a>The Background</h2><ol><li>talking about the <strong>reasons</strong> why i choose this topic(relative each time visit her, she don’t know who am i, a lot of news reports people sufffer from dementia)</li><li>then explore the <strong>symptom of dementia</strong>, the <strong>currently treatment for dementia</strong>.</li><li>the study of elderly people</li><li>cognitive functions(memory, attention, comprehension, language)</li><li>VR, AR, MR comparision<a id="more"></a></li></ol><h2 id="VR-Garden-Design"><a href="#VR-Garden-Design" class="headerlink" title="VR Garden Design"></a>VR Garden Design</h2><ol><li>unity 3d</li><li>C#</li></ol><h2 id="Evaluation-method"><a href="#Evaluation-method" class="headerlink" title="Evaluation method"></a>Evaluation method</h2><ol><li>questionnaires(SUS, general interest, attitude, modified banos)</li><li>pulse rate monitor</li></ol><h2 id="results"><a href="#results" class="headerlink" title="results"></a>results</h2><ol><li>positive feedback</li><li>perceied has a positive effect</li><li>during the interaction with VR garden, participants need to using memory, thinking, attention ability, this is a way to exercise these functions, to keep brain working. and study the behavior of elderly people in virtual world.</li></ol><h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><ol><li>we can build the enriched environment for elderly people and keep modification. Then, apply this modification in real world. Finally, to help elderly people.</li><li>pulse rate monitor shows the rate line is very smooth and no big difference. Just a littole fluctuation on wearing the headset. Explaining this for use the ner technology and exercited o new things<br>3.</li></ol>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一切为了通过面试（为面试而准备）</title>
      <link href="/2018/08/17/learning/"/>
      <url>/2018/08/17/learning/</url>
      <content type="html"><![CDATA[<p><em>在这一篇中，记录的知识点会很杂,因为这是为了面试而搜索整理的，可以没事拿来读一读，或多或少都会有帮助。</em></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>通常状况下，我们会有大量的数据需要存储，分析和处理。而当前市场上，动辄上百G的内容。对于如此大的数据，查找起来会非常的耗时耗资源，一般查找方法</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sslect * form table</span><br><span class="line">where name &lt; 30</span><br></pre></td></tr></table></figure><p>用这种方法，需要将数据库中的数据整体过滤一遍，才能找到符合要求的对象。当对象上千万上亿的时候，很显然我们需要寻找更优的方法。那就是<strong>索引</strong>。</p><p>索引是属于表中的列数据。是一种数据结构，我们通过查找索引来查找数据会大大提高效率。而在索引中有<strong>B-TREE, R-TREE, 哈希索引</strong>等方法，下面我一一介绍。</p><h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h3><p>Balance tree，平衡树，不同于二叉树，而它又是基于二叉树发展而来。因为我们希望二叉树矮胖长，减少度。B的结点不限制于两个，可以有更多。</p><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="一些常用函数"><a href="#一些常用函数" class="headerlink" title="一些常用函数"></a>一些常用函数</h2><ol><li><p>itoa()</p></li><li><p>strcmp(), str</p></li></ol><h2 id="构造函数-析构函数"><a href="#构造函数-析构函数" class="headerlink" title="构造函数 析构函数"></a>构造函数 析构函数</h2><ol><li>构造函数</li></ol><p>通俗的讲，在类中，函数名和类名相同的函数，称为构造函数。</p><p><strong>作用：</strong> 在建立一个对象时，做某些初始化工作（赋初始值）。c++是<strong>允许同名函数</strong>，也就是允许一个类中有多个构造函数。如果一个都没有，编译器将为该类产生一个默认的构造函数。</p><p><strong>限制：</strong> 构造函数不能指定<em>返回类型</em>，void也不行</p><p><strong>参数：</strong>不带参数的构造函数，只能以固定不变的值初始化对象。带参数的构造函数灵活的多，通过传递给构造函数的参数，可以赋予对象不同的初始值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数名（形参表）</span><br></pre></td></tr></table></figure><p>创建对象时使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 （实参表）</span><br></pre></td></tr></table></figure></p><ol start="2"><li>析构函数</li></ol><p>析构函数也是函数名与类名相同，不过要在函数前加上~符号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class line()</span><br><span class="line">&#123;</span><br><span class="line">  ~line()      //析构函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>析构函数主要是用来在消灭对象的时候调用，用来关闭文件，释放内存等。<br><strong>一个类只允许有一个析构函数</strong></p><p><strong>对象析构顺序</strong> 后构造的对象先析构</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>它重复走访需要排序的元素列，一次比较两个相邻的元素，按照要求（大小）来进行元素交换。最大数会换到元素顶端。**时间复杂度O（n^2).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define  SIZE 8</span><br><span class="line"></span><br><span class="line">void bubble_sort(int a[], int n);</span><br><span class="line"></span><br><span class="line">void bubble_sort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">  int i, j, temp;</span><br><span class="line">  for(j = 0; j&lt; n -1 ; j++)   //最大数不用比较所以n-1</span><br><span class="line">     for( i = 0; i&lt; n-1-j;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       if(a[i] &gt; a[i+1])</span><br><span class="line">       &#123;</span><br><span class="line">         temp = a[i];</span><br><span class="line">         a[i] = a[i+1];</span><br><span class="line">         a[i+1] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int number[SIZE] = &#123;95, 45, 15, 76, 87, 67,54,12&#125;;</span><br><span class="line">  int i;</span><br><span class="line">  bubble_sort(number, SIZE);</span><br><span class="line">  for(i = 0; i&lt;SIZE; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, number[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是对冒泡排序的一种改进。<br>基本思想：通过一趟排序将要排序的序列分割成独立的两部分，一部分的数据要比另一份的数据大。。然后再按照此方法对这两部分的数据进行快速排序，递归进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a[101],n;    //定义全局变量，这两个变量需要在子函数中使用</span><br><span class="line">void quicksort(int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">  int i,j,t,temp;</span><br><span class="line">  if(left&gt;right)</span><br><span class="line">  &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  temp = a[left]; //temp中存的就是基准书</span><br><span class="line">  i = left;</span><br><span class="line">  j = right;</span><br><span class="line">  while(i!=j)</span><br><span class="line">  &#123;</span><br><span class="line">      //顺序很重要，要先从右边开始找</span><br><span class="line">      while(a[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">           j--;</span><br><span class="line">     //再找右边的</span><br><span class="line">     while(a[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">           i++;</span><br><span class="line">     //交换两个数在数组中的位置</span><br><span class="line">     if(i &lt; j)</span><br><span class="line">     &#123;</span><br><span class="line">       t = a[i];</span><br><span class="line">       a[i] = a[j];</span><br><span class="line">       a[j] = t;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> //最终将基数归位</span><br><span class="line"> a[left] = a[i];</span><br><span class="line"> a[i] = temp;</span><br><span class="line"></span><br><span class="line"> quicksort(left, i -1 ) //继续处理左边的，这里是一个递归的过程</span><br><span class="line"> quicksort(i+1, right)  //继续处理右边的，这里是一个递归的过程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mian()</span><br><span class="line">&#123;</span><br><span class="line">  int i,j,t;</span><br><span class="line">  //读入数据</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">  for(i = 1; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">     scanf(&quot;%d&quot;, &amp;a[i]);  </span><br><span class="line">  &#125;</span><br><span class="line">  quicksort(1,n);   //快速排序调用</span><br><span class="line"></span><br><span class="line">  //输出排序后的结果</span><br><span class="line">  for(i=1; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;%d&quot;,a[i]);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>快速排序的每一步处理其实就是将这一步的基准书归位</em></strong></p><p>相比于冒泡排序，快速排序的每次交换是跳跃式的。每次排序的时候设置一个基准数，将小于等与基准数的数全部放在基准数的左边，大于等与的放在右边。这样每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总比较和交换次数就变少了，速度自然就提高了。</p><p>当然在最坏情况下，仍然可能是相邻两个数进行交换。最差时间复杂度和冒泡排序一样都是O(n2)， 但是它的平均时间复杂度是O(nlogn).</p><p>快速排序基于“二分思想”</p><hr><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度主要是用来进行计算并了解整个算法的时间占有，也就是占用的时间。通常我们会看到几种时间复杂度<strong>O(1), O(n), O(n2), O(logn), O(nlogn),O（2^n）</strong>等等</p><ol><li>O（1）</li></ol><p>是常数时间复杂度，也就是说有唯一对应的映射。</p><ol start="2"><li>O(n)</li></ol><p>是线性时间复杂度，我看到过一个形象的举例，有一堆水果：苹果，梨子，猕猴桃等等，我想要苹果，你就帮我拿苹果，我想要梨子你帮我拿梨子，我想要拿哪一个都有<em>一一对应</em>的映射<br>。再比如，这个时候我妈买了菠萝，火龙果等其他新水果，放在之前那一堆中，但是我仍然想要苹果，你不会给我拿梨子或者火龙果，仍然是一一对应，这就是线性时间复杂度。</p><ol start="3"><li>O(n2)</li></ol><p>平方复杂度，不仅仅只代表平方，代表的是最高次幂，最后简化为最高次项。上面算法排序里面的冒泡排序就是平方复杂度的一个典型例子。因为我们需要在n-1次的n-j-1次里进行遍历，我们最终取得最高次幂是2，也就是n2</p><ol start="4"><li>O(logn)</li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是二叉树的一种，比二叉树效率高。</p><h2 id="malloc-free与new-delete的区别"><a href="#malloc-free与new-delete的区别" class="headerlink" title="malloc free与new delete的区别"></a>malloc free与new delete的区别</h2><ol><li>malloc free是标准c++/c库函数，new delete是c++关键字。</li><li><em>（对象在创建的同时要自动执行构造函数，在销毁之时要自动执行析构函数）</em>new delete会在使用的时候自动调用<strong>构造函数</strong>和<strong>析构函数</strong>，而malloc free不会，malloc需要自行调用initialize(),free需要自行调用destroy()来达到和new delete一样的效果。</li><li>俩函数都会在内存泄漏的时候，显示提示信息，但是new delete会显示具体哪一个文件哪一行，</li></ol><p><strong>既然new delete这么好，为啥还需要malloc free呢？？？？？</strong></p><p><strong><em>那是因为，C语言库里面只有malloc free,c++和c经常需要配合使用，也就是说malloc free和new delete也需要配合使用。他们一样都是成对出现的</em></strong></p><h1 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h1><ol><li><p>功能测试： specifications的满足</p></li><li><p>UI测试： 用户喜好</p></li><li><p>性能测试:  打开一个网站的时间</p></li><li><p>优化测试： 哪里还需要改进</p></li></ol>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Several ways to increase Python performance</title>
      <link href="/2018/08/12/performance/"/>
      <url>/2018/08/12/performance/</url>
      <content type="html"><![CDATA[<p><strong><em>python本身就跑不过C, 干不过C++，性能方面是个软肋。所以高效编程尤为重要。</em></strong></p><hr><h1 id="1-import的使用"><a href="#1-import的使用" class="headerlink" title="1. import的使用"></a>1. import的使用</h1><a id="more"></a><p>在导入需要使用到的模块之前，一定要确定，要用到模块里的哪个函数。因为直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import numpy</span><br><span class="line">import matplotlib</span><br></pre></td></tr></table></figure><p>每次编译都会重复调用，大大降低系统速度。在确定了具体函数之后，我们可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure></p><p>因为局部模块引用会<strong>提高运行速度</strong></p><p>。这样的模块使用还有另一个优点，就是<strong>增强了可阅读性。</strong></p><hr><h1 id="2-使用映射来替换条件搜索"><a href="#2-使用映射来替换条件搜索" class="headerlink" title="2. 使用映射来替换条件搜索"></a>2. 使用映射来替换条件搜索</h1><p>提到映射，python拥有dict等，dict就是字典，顾名思义，就是查找。也就是<strong>一一对应的关系</strong>。 在Python中没有select-case语句。dict的搜索条件比if快很多，所以 <strong>当想用if的时候，尝试去使用dict吧</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#if search</span><br><span class="line">if a== 1:</span><br><span class="line">   b = 10</span><br><span class="line">else a == 2:</span><br><span class="line">   b = 20</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># dict search: better performance</span><br><span class="line">d = &#123;1:10, 2:20, ...&#125;</span><br><span class="line">b = d[a]</span><br></pre></td></tr></table></figure><p>这里强调一下dict,使用的是大括号，而且内部元素是映射关系（一一对应）</p><h1 id="3-减少函数调用的数量"><a href="#3-减少函数调用的数量" class="headerlink" title="3. 减少函数调用的数量"></a>3. 减少函数调用的数量</h1><p>很多时候，我们需要去确认对象的类型，才能进行下一步操作。type()是常用的，如名字所示，检测类型。但是其实isinstance()最好，id()次之，type()最差</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#determine the variable type is integer</span><br><span class="line">type(a) == type(0) #call the function three times</span><br><span class="line">type(a) is type(0) #identity comparision</span><br><span class="line">isinstance(a,(int)) #call the function performance</span><br></pre></td></tr></table></figure><p>为了避免重复计算，避免把重复操作放到循环中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#each loop needs to re-excute len(a)</span><br><span class="line">while i &lt; len(a):</span><br><span class="line">    statement</span><br><span class="line"></span><br><span class="line">#put len(a) outside loop</span><br><span class="line">m = len(a)</span><br><span class="line">while i &lt; m</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>当使用模块中的函数或者对象时，from x import y比较好而不是直接import x.<br>可以减少一次查询，解析器不需要先找到模块x,然后在模块的字典中找y</p><h1 id="4-使用局部变量"><a href="#4-使用局部变量" class="headerlink" title="4. 使用局部变量"></a>4. 使用局部变量</h1><p>局部变量易于维护，并且节约性能提高成本。因此尽量避免全局变量。</p><p>在模块命名空间中，将变量替换为局部变量是很有利的。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls = os.linesep</span><br></pre></td></tr></table></figure></p><p>两个好处</p><ol><li>提高程序性能，因为局部变量搜索速度快</li><li>使用短标识替换长模块变量，提高阅读性</li></ol><h1 id="5-直接迭代序列元素"><a href="#5-直接迭代序列元素" class="headerlink" title="5. 直接迭代序列元素"></a>5. 直接迭代序列元素</h1><p>对于序列（list, str, tuple等）。直接迭代序列元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">for item in a</span><br><span class="line">   print(item)</span><br></pre></td></tr></table></figure><h1 id="6-用生成器表达式替换列表解析"><a href="#6-用生成器表达式替换列表解析" class="headerlink" title="6. 用生成器表达式替换列表解析"></a>6. 用生成器表达式替换列表解析</h1><p>列表解析生成整个列表，会对大量数据的迭代产生负面作用。<br>而生成器表达式则不会，生成器表达式不会创建一个列表，相反返回一个生成器，在需要的时候生成具体数值（延迟的），<strong>这种方式对内存友好</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#calculate the number of none-null characters in file f</span><br><span class="line">#list analysis</span><br><span class="line">l = sum([len(word) for line in f for word in line.split()])</span><br><span class="line">#generator expression</span><br><span class="line">l = sum(len(word) for line in f for word in line.split())</span><br></pre></td></tr></table></figure><h1 id="7-先编译后调用"><a href="#7-先编译后调用" class="headerlink" title="7.先编译后调用"></a>7.先编译后调用</h1><p>当使用函数eval()和exec()来执行代码时，最好调用代码对象（通过compile（）预先编译成字节码）而不是直接调用str,这样可以避免重复编译过程多次和提高程序性能。</p><p>正则表达式模式匹配是类似的，在执行比较和匹配前，最好将正则匹配表达式模式编译为正则表达式对象。（通过re.compile()函数）</p><h1 id="8-模块编程"><a href="#8-模块编程" class="headerlink" title="8.模块编程"></a>8.模块编程</h1><p>模块中最高级别的Python语句(无缩进代码)将再导入模块时执行，这里有个问题，是否所有代码都需要执行? 我们需要将模块的所有功能代码放入函数中(与主程序相关的功能代码也可以放在main()函数中，主程序本身调用main()函数)</p><p>测试代码可以写在模块的main()函数中，将在主程序中检测 <strong>name</strong> 的值，如果是<strong>main</strong>(表示模块直接执行)，则调用main()函数进行测试，如果它是模块的名称，表示模块被调用，则不会执行测试。</p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python+Sqlite3+Opencv自动化测试（STB本地服务器_页面抓取_图片对比）</title>
      <link href="/2018/08/10/python-Sqlite3-Opencv/"/>
      <url>/2018/08/10/python-Sqlite3-Opencv/</url>
      <content type="html"><![CDATA[<p><em>实习期间做的小项目，整理一下：</em></p><p>STB服务器搭建起来后，需要检测显示的内容与期望匹配。这里就需要一个自动化测试工具。</p><p><strong>Python</strong> 作为编程脚本语言，因为其中含有大量的库可以引用，会大大加快开发效率。其中的webdriver, PIL, tkinter等库将发挥巨大的作用。</p><p>在图片对比方面，使用 <strong>opencv</strong> ，因为其适用于各大主流平台，具有强移植性。</p><p>数据库本来想用MySQL, 后来发现python有自带的 <strong>SQlite3</strong> 数据库，这是一个轻量级数据库，适合处理数据量不是很大的项目，加上python有内置module,因此使用起来非常方便。以上就是这个项目的主要架构。</p><a id="more"></a><hr><h1 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h1><p>搭建一个UI界面，将接口展示出来，方便用户进行自主配置。<br>python有三个主流UI设计Module，这里我选择tkinter, 因为以前用过，写过一个计算器，哈哈哈。Python的UI设计确实方便，但是局限性也很明显，不那么灵活，不过对于自主测试，清楚易于使用就可以啦。</p><p><strong>关于UI界面，留了两个接口：</strong></p><ol><li>想要测试的网址的URL输入</li><li>数据库里内置的tag选择（就是想要测试页面的预制图片）</li></ol><p><strong>关于数据库</strong><br>SQlite3是python内置轻量型数据库，非常适合中小型项目数据操作。其也是使用标准的SQL语句。（幸好，之前有接触过MySQL，所以上手没那么难）</p><ol><li>建立img_set表</li><li>表中有三个组（ID, TAG, PATH）ID对应预制图片编号，TAG对应预制图片网址，PATH对应预制图片本地路径。</li></ol><p><strong>关于图片对比</strong><br>图片咋对比，首先要分析图片包含的因素，有：颜色，文理，框架，密度等。相对于这些因素，我选择了直方图计算法，来计算两个图片的密度差值。越小越相似。但是对于浏览器检测，需要精密测试，甚至字符，这种基于颜色密度的方法作罢。选择opencv的哈希算法。</p><p><strong>关于python</strong><br>这一点写在最后，因为能分析的点太多了。从python脚本直接执行shell命令，进行screencap,保存到本地，名字的定义。我采用了模块化设计的方法。定义了相关函数，在UI界面交互的时候，就会触发这些函数，进行测试。<br>python太强大，但是往往会忽略底层的东西。而这些恰恰是高精尖人才的必修。</p><h1 id="python中需要注意的点"><a href="#python中需要注意的点" class="headerlink" title="python中需要注意的点"></a>python中需要注意的点</h1><p>在将本地路径导入数据库的时候，老是报错。具体错误（不识别|），或者其他的错误。加了r之后仍然报错。这是什么原因呢？经查证，需要在路径前后都加上“\”。原因后补？</p><p>还有就是 <strong>tuple</strong> 转 <strong>list</strong> 的问题，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(&quot;http://baidu.com&quot;)]</span><br></pre></td></tr></table></figure><p>slect数据库之后显示的是上述输出<br>而我们需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;http://baidu.com&quot;</span><br></pre></td></tr></table></figure><p>也就是不需要小括号和中括号，我用了type去测试地址类型，都显示为list，其实关于类型测试，<strong><em>isinstance比type好用。</em></strong> 这个就用到了如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pathset = []</span><br><span class="line">for row in path:</span><br><span class="line">   finalpath = &apos;&apos;.join(row)</span><br><span class="line">   pathset.append(finalpath)</span><br><span class="line">print(pathset)</span><br></pre></td></tr></table></figure><p>这是一个非常巧妙的方法，用到了join，将list中每个元素都单独取出来，并且用空连接。最重要的有一点是，我提前定义了一个空list，将每次取出来的值以此放到空list里，这样就会出现想要的结果。</p><p>在整体开发过程中真的遇到相当多问题，比编程更重要的是 <strong>学习力</strong> 和 <strong>适应力</strong> ，此外还有 <strong>承受力</strong> ，加油吧少年！</p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git基本操作</title>
      <link href="/2018/07/25/git/git/"/>
      <url>/2018/07/25/git/git/</url>
      <content type="html"><![CDATA[<p><strong>github已经建了一个月了，还是不会把代码传上去<img class="github-emoji" title="expressionless" alt="expressionless" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f611.png?v8" height="20" width="20">最近写了不少脚本，所以趁这个机会学习一下<img class="github-emoji" title="stuck_out_tongue_winking_eye" alt="stuck_out_tongue_winking_eye" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f61c.png?v8" height="20" width="20"></strong></p><p><a href="https://i.loli.net/2018/07/26/5b58d5df2c0c7.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/07/26/5b58d5df2c0c7.png" alt="github.svg.png"></a></p><h1 id="第一步-github官网操作"><a href="#第一步-github官网操作" class="headerlink" title="第一步 github官网操作"></a>第一步 github官网操作</h1><a id="more"></a><ol><li>在github首页也就是官网上建立一个<strong>new repository</strong></li><li>建好之后，右上角会有<strong>clone or download，copy</strong>那个地址</li></ol><h1 id="第二步-本地操作"><a href="#第二步-本地操作" class="headerlink" title="第二步 本地操作"></a>第二步 本地操作</h1><ol><li>右键想要上传的项目，点击<strong>git bash here</strong>， 进入下面页面，Test_Bluetooth即为项目名。</li></ol><p><a href="https://i.loli.net/2018/07/26/5b58d62f12bed.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/07/26/5b58d62f12bed.png" alt="913913-20160823171048308-194895299.png"></a></p><ol start="2"><li>将刚刚建立仓库的地址<strong>克隆到本地</strong></li></ol><p>git clone （刚刚复制的地址） -<em>不要括号</em></p><p><a href="https://i.loli.net/2018/07/26/5b58d62f45945.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/07/26/5b58d62f45945.png" alt="913913-20160823171143980-741152042.png"></a></p><p>做完这一步就会在项目的目录里出现新建的一个文件夹，名字为刚刚在网页上建立仓库的名字。<br>将所有的文件都放到这个新建的文件里。</p><ol start="3"><li>cd test (test为仓库名字）</li><li>git add</li><li>git commit -m first(first是想要提交的信息会显示在github文件名的后面）</li><li>git push -u origin master (目的是把本地仓库push到github上）</li></ol><p>嘻嘻，是不是很简单。喜欢<strong>打赏一下</strong>呀！<img class="github-emoji" title="blush" alt="blush" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60a.png?v8" height="20" width="20"><img class="github-emoji" title="blush" alt="blush" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60a.png?v8" height="20" width="20"><img class="github-emoji" title="blush" alt="blush" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60a.png?v8" height="20" width="20"></p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>终于~把个人博客搭建起来了！</title>
      <link href="/2018/07/22/%E7%BB%88%E4%BA%8E%EF%BC%81%E6%8A%8A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%B5%B7%E6%9D%A5%E4%BA%86%EF%BC%81/%E7%BB%88%E4%BA%8E%EF%BC%81%E6%8A%8A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%B5%B7%E6%9D%A5%E4%BA%86%EF%BC%81/"/>
      <url>/2018/07/22/%E7%BB%88%E4%BA%8E%EF%BC%81%E6%8A%8A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%B5%B7%E6%9D%A5%E4%BA%86%EF%BC%81/%E7%BB%88%E4%BA%8E%EF%BC%81%E6%8A%8A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%B5%B7%E6%9D%A5%E4%BA%86%EF%BC%81/</url>
      <content type="html"><![CDATA[<h1 id="终于把个人博客做出来了"><a href="#终于把个人博客做出来了" class="headerlink" title="终于把个人博客做出来了"></a>终于把个人博客做出来了</h1><p><em>今天是7月22号周日</em></p><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>–</p><p>我很<del>开心，激动</del>，咳咳，困~~~<br><a id="more"></a><br>以后会间歇性把我的学习笔记和感悟post上来，作为个人学术积累。</p><p>其实我。。。</p><p>比较喜欢发微博，可以来我<a href="https://weibo.com/u/3526038944/home?wvr=5" target="_blank" rel="noopener">微博互动</a></p><p>或者直接在本博客下面留言，欢迎探讨各类<del>学术知识</del>，生活分享，人生感悟。</p><p><a href="https://i.loli.net/2018/07/25/5b5795394484c.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/07/25/5b5795394484c.png" alt="Student-3-icon.png"></a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Markdown语法总结</title>
      <link href="/2018/07/22/markdown/Markdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/22/markdown/Markdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p><a href="https://i.loli.net/2018/07/25/5b5796e43f2a9.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/07/25/5b5796e43f2a9.png" alt="dsfdfs.png"></a></p><p><strong>Markdown</strong> 是搭建网站必须，所以才学习的。但是在学习和应用的同时，发现这个语法精简了工作，提高了效率。因为它<em>偏重内容而不是格式</em>。以往我们写一遍文章，需要花比较多的时间在格式的排版上，比如页边距，行距，字体等等，而在Markdown里，使用标准定义的语法，减去了这些排版步骤，让人们将精力更多的集中在内容梳理上。这个语法规则大受欢迎是不无道理的。</p><h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">（以此类推）</span><br></pre></td></tr></table></figure><p>这里注意：<strong>一定要在#前加空格</strong></p><p>显示的效果为</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><p><strong>加粗</strong></p><p>要加粗的文字左右分别用两个*号包起来</p><p><strong>斜体</strong></p><p>要倾斜的文字左右分别用一个*号包起来</p><p><strong>斜体加粗</strong></p><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><p><strong>删除线</strong></p><p>要加删除线的文字左右分别用两个~~号包起来</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><p>效果如下：<br><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>符号 &gt; 大于号<br>随便几个大于号都等同于引用，至少一个，多写无妨，看心情咯。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用一下看看</span><br></pre></td></tr></table></figure><p>显示：</p><blockquote><p>应用一下看看</p></blockquote><h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>需要三个以上的-或者*</p><hr><hr><h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p>图片需要注意，本地的有点麻烦还得弄到GitHub库，所以选择一个合适的图床来的简单方便。<br>我用的是：<a href="https://sm.ms/" target="_blank" rel="noopener">SM.,MS</a><br>非常好用，上传图片后有直接的Markdown链接引用。</p><p>图片的格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片名](图片地址)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/23/5b54fc9f6d48a.jpg" alt="green.jpg"></p><p>这是图片不带链接的，带链接的跟上面引用网站的一样啦。</p><h1 id="六、列表"><a href="#六、列表" class="headerlink" title="六、列表"></a>六、列表</h1><p><strong>无序列表</strong></p><p>-+*三种其一都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-内容</span><br><span class="line">+内容</span><br><span class="line">*内容</span><br></pre></td></tr></table></figure><p>-嗯嗯</p><p>+嗯嗯</p><p>*嗯嗯</p><p><strong> 有序列表</strong></p><p>···<br>1.内容<br>2.内容<br>3.内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**列表嵌套**</span><br><span class="line"></span><br><span class="line">上级和下级之间敲三个空格</span><br></pre></td></tr></table></figure></p><p>-eee</p><ol><li>aaa</li><li>eee<br>···</li></ol><p>-eee</p><ol><li>f</li><li>f</li></ol><h1 id="七、表格"><a href="#七、表格" class="headerlink" title="七、表格"></a>七、表格</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br></pre></td></tr></table></figure><p>第二行分割表头和内容。</p><ul><li>有一个就行，为了对齐，多加了几个<br>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略</li></ul><table><thead><tr><th>list</th><th style="text-align:left">list</th><th>list:</th></tr></thead><tbody><tr><td>content</td><td style="text-align:left">content</td><td>content</td></tr></tbody></table><h1 id="八、代码"><a href="#八、代码" class="headerlink" title="八、代码"></a>八、代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码</span><br></pre></td></tr></table></figure><h1 id="九、流程图"><a href="#九、流程图" class="headerlink" title="九、流程图"></a>九、流程图</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure><p>flow<br>st=&gt;start: 开始<br>op=&gt;operation: My Operation<br>cond=&gt;condition: Yes or No?<br>e=&gt;end<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br>&amp;</p>]]></content>
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
